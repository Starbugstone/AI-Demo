<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Particle Playground</title>
    <style>
      :host {
        font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
        color: #f8fafc;
      }

      body {
        margin: 0;
        padding: 0;
        background: transparent;
      }

      .deck {
        display: grid;
        gap: 1.2rem;
        padding: 1.5rem;
        border-radius: 1.5rem;
        border: 1px solid rgba(59, 130, 246, 0.35);
        background: radial-gradient(circle at 20% 20%, rgba(59, 130, 246, 0.16), transparent 55%),
          radial-gradient(circle at 80% 0%, rgba(236, 72, 153, 0.12), transparent 60%),
          rgba(15, 23, 42, 0.82);
        box-shadow: 0 1.25rem 2.5rem rgba(2, 6, 23, 0.55);
      }

      header h2 {
        margin: 0 0 0.4rem;
        font-size: 1.5rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      header p {
        margin: 0;
        color: rgba(203, 213, 225, 0.82);
        line-height: 1.6;
      }

      canvas {
        width: min(640px, 100%);
        height: calc(min(640px, 100%) * 0.66);
        border-radius: 1.25rem;
        display: block;
      }

      footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem;
        font-size: 0.85rem;
        color: rgba(148, 163, 184, 0.88);
      }

      .metrics {
        display: inline-flex;
        gap: 1rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .metrics span::before {
        content: "";
        display: inline-block;
        width: 0.45rem;
        height: 0.45rem;
        border-radius: 999px;
        background: currentColor;
        margin-right: 0.35rem;
        opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <section class="deck" role="application" aria-label="Particle Playground">
      <header>
        <h2>Particle Playground</h2>
        <p>
          Thousands of motion vectors bend shimmering motes into orbit. Drag to sculpt the flow and release
          to watch the field recover.
        </p>
      </header>
      <canvas id="particle-stage"></canvas>
      <footer>
        <div class="metrics">
          <span data-role="count">0 motes</span>
          <span data-role="fps">0 fps</span>
        </div>
        <span>Pointer: drag to attract, double-tap to toggle pulse mode.</span>
      </footer>
    </section>

    <script>
      const root = document.currentScript.getRootNode();
      const hostDocument = root.host?.ownerDocument || root;
      const defaultView = hostDocument.defaultView;
      const canvas = root.getElementById('particle-stage');
      const ctx = canvas.getContext('2d');
      const metrics = {
        count: root.querySelector('[data-role="count"]'),
        fps: root.querySelector('[data-role="fps"]'),
      };

      const DPR = window.devicePixelRatio || 1;
      const state = {
        width: 640,
        height: 420,
      };

      const PARTICLE_COUNT = 420;

      const createParticle = (index) => {
        const hue = 190 + ((index / PARTICLE_COUNT) * 120) % 120;
        const x = Math.random() * state.width;
        const y = Math.random() * state.height;
        return {
          x,
          y,
          prevX: x,
          prevY: y,
          angle: Math.random() * Math.PI * 2,
          speed: 0.35 + Math.random() * 0.75,
          hue,
        };
      };

      const particles = Array.from({ length: PARTICLE_COUNT }, (_, index) => createParticle(index));

      const pointer = {
        active: false,
        x: state.width / 2,
        y: state.height / 2,
        strength: 0,
        pulse: false,
      };

      metrics.count.textContent = `${particles.length} motes`;

      const resize = () => {
        const rect = canvas.getBoundingClientRect();
        state.width = rect.width;
        state.height = rect.height;
        canvas.width = rect.width * DPR;
        canvas.height = rect.height * DPR;
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      };

      const vectorField = (x, y, time) => {
        const scale = 0.0028;
        const angle =
          Math.sin(x * scale + time * 0.6) * 1.2 + Math.cos(y * scale * 1.3 - time * 0.9) * 0.8;
        const magnitude = 0.8 + 0.35 * Math.sin(time * 0.7 + x * 0.005 - y * 0.004);
        return {
          vx: Math.cos(angle) * magnitude,
          vy: Math.sin(angle) * magnitude,
        };
      };

      const updateParticles = (time) => {
        const pointerInfluence = pointer.active ? 0.12 : 0.02;
        const pulse = pointer.pulse ? 0.65 + Math.sin(time * 0.004) * 0.35 : 0;

        particles.forEach((particle, index) => {
          particle.prevX = particle.x;
          particle.prevY = particle.y;

          const field = vectorField(particle.x + index * 0.3, particle.y - index * 0.2, time * 0.0015);

          particle.angle += (field.vx + field.vy) * 0.035;
          const vx = Math.cos(particle.angle) * particle.speed + field.vx * 0.25;
          const vy = Math.sin(particle.angle) * particle.speed + field.vy * 0.25;

          if (pointerInfluence > 0) {
            const dx = pointer.x - particle.x;
            const dy = pointer.y - particle.y;
            const distanceSq = Math.max(dx * dx + dy * dy, 64);
            const attraction = pointerInfluence * (pointer.strength + pulse) / distanceSq;
            particle.x += dx * attraction * 280;
            particle.y += dy * attraction * 280;
          }

          particle.x = (particle.x + vx + state.width) % state.width;
          particle.y = (particle.y + vy + state.height) % state.height;
        });
      };

      const renderParticles = (time) => {
        ctx.fillStyle = 'rgba(4, 9, 22, 0.24)';
        ctx.fillRect(0, 0, state.width, state.height);

        ctx.lineCap = 'round';
        ctx.lineWidth = 1.25;

        particles.forEach((particle, index) => {
          const hue = (particle.hue + time * 0.03 + index * 0.35) % 360;
          ctx.strokeStyle = `hsla(${hue}, 80%, 65%, 0.75)`;
          ctx.beginPath();
          ctx.moveTo(particle.prevX, particle.prevY);
          ctx.lineTo(particle.x, particle.y);
          ctx.stroke();
        });

        if (pointer.active) {
          const gradient = ctx.createRadialGradient(pointer.x, pointer.y, 0, pointer.x, pointer.y, 120);
          gradient.addColorStop(0, 'rgba(96, 165, 250, 0.22)');
          gradient.addColorStop(1, 'rgba(96, 165, 250, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(pointer.x, pointer.y, 120, 0, Math.PI * 2);
          ctx.fill();
        }
      };

      let lastTimestamp = performance.now();
      let frameCount = 0;
      let fpsAccumulator = 0;

      const tick = (timestamp) => {
        const delta = timestamp - lastTimestamp;
        lastTimestamp = timestamp;
        frameCount += 1;
        fpsAccumulator += delta;

        if (fpsAccumulator >= 1000) {
          metrics.fps.textContent = `${Math.round((frameCount * 1000) / fpsAccumulator)} fps`;
          frameCount = 0;
          fpsAccumulator = 0;
        }

        updateParticles(timestamp);
        renderParticles(timestamp);
        requestAnimationFrame(tick);
      };

      const updatePointer = (event) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = state.width / rect.width;
        const scaleY = state.height / rect.height;
        pointer.x = (event.clientX - rect.left) * scaleX;
        pointer.y = (event.clientY - rect.top) * scaleY;
      };

      canvas.addEventListener('pointerdown', (event) => {
        pointer.active = true;
        pointer.strength = 1;
        updatePointer(event);
        canvas.setPointerCapture(event.pointerId);
      });

      canvas.addEventListener('pointermove', (event) => {
        if (!pointer.active) return;
        updatePointer(event);
      });

      const endPointer = () => {
        pointer.active = false;
        pointer.strength = 0.2;
      };

      canvas.addEventListener('pointerup', endPointer);
      canvas.addEventListener('pointercancel', endPointer);

      canvas.addEventListener('dblclick', () => {
        pointer.pulse = !pointer.pulse;
      });

      resize();
      requestAnimationFrame(tick);

      const observer = new ResizeObserver(() => resize());
      observer.observe(canvas);

      defaultView?.addEventListener('resize', resize);
      hostDocument.addEventListener('visibilitychange', () => {
        if (hostDocument.hidden) {
          pointer.active = false;
          pointer.strength = 0.2;
        }
      });
    </script>
  </body>
</html>
