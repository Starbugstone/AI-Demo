<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Neon Pipelines</title>
    <style>
      :host {
        display: block;
        width: 100%;
        height: 100%;
        font-family: "Space Grotesk", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: var(--text-primary, #f8fafc);
        background: radial-gradient(circle at 20% 20%, rgba(46, 213, 255, 0.12), transparent 60%),
          radial-gradient(circle at 80% 30%, rgba(255, 55, 145, 0.16), transparent 55%),
          linear-gradient(160deg, rgba(10, 17, 40, 0.95), rgba(5, 9, 24, 0.98));
      }

      body {
        margin: 0;
        height: 100%;
        display: grid;
        place-items: center;
        background: transparent;
      }

      .hud {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        pointer-events: none;
        padding: 24px;
      }

      .hud-top {
        width: 100%;
        display: flex;
        justify-content: space-between;
        font-size: 1.1rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(240, 249, 255, 0.85);
        text-shadow: 0 0 10px rgba(94, 234, 212, 0.35);
      }

      .hud-bottom {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.35rem;
        font-size: 0.95rem;
        color: rgba(226, 232, 240, 0.8);
        text-shadow: 0 0 12px rgba(14, 165, 233, 0.45);
      }

      canvas {
        width: min(360px, 80vw);
        height: auto;
        max-height: 80vh;
        border-radius: 24px;
        box-shadow: 0 25px 55px rgba(15, 23, 42, 0.75), 0 0 0 1px rgba(148, 163, 184, 0.25);
      }

      .container {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .pulse {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
      }

      .pulse::before {
        content: "";
        display: inline-block;
        width: 0.65rem;
        height: 0.65rem;
        border-radius: 999px;
        background: #38bdf8;
        box-shadow: 0 0 12px rgba(56, 189, 248, 0.9);
        animation: throb 1.8s ease-in-out infinite;
      }

      @keyframes throb {
        0%,
        100% {
          transform: scale(1);
          opacity: 0.75;
        }
        50% {
          transform: scale(1.35);
          opacity: 1;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <canvas id="game" width="360" height="640" aria-label="Flappy neon bird playground"></canvas>
      <div class="hud" aria-hidden="true">
        <div class="hud-top">
          <span id="score">000</span>
          <span id="best">BEST 000</span>
        </div>
        <div class="hud-bottom">
          <span class="pulse" id="hint">Tap or press space to boost</span>
          <span id="status">Stay between the gates</span>
        </div>
      </div>
    </div>

    <script>
      const root = document.currentScript.getRootNode();
      const canvas = root.getElementById("game");
      const ctx = canvas.getContext("2d");
      const scoreEl = root.getElementById("score");
      const bestEl = root.getElementById("best");
      const statusEl = root.getElementById("status");
      const hintEl = root.getElementById("hint");

      const state = {
        running: false,
        gameOver: false,
        width: canvas.width,
        height: canvas.height,
        gravity: 900,
        jump: -320,
        pipeSpacing: 1.65,
        pipeGap: 180,
        pipeSpeed: 190,
        timeSincePipe: 0,
        bird: {
          x: 120,
          y: 320,
          radius: 18,
          velocity: 0,
          wobble: 0,
        },
        pipes: [],
        score: 0,
        best: 0,
        multiplier: 1,
        lastSpawnY: 320,
        backgroundLayers: [],
        nebulae: [],
        galaxies: [],
        lightStreaks: [],
        trail: [],
        trailCooldown: 0,
        trailBoost: 0,
        shake: {
          elapsed: 1,
          duration: 0,
          intensity: 0,
        },
      };

      function initializeCosmos() {
        const layerConfigs = [
          {
            count: 52,
            speed: 12,
            parallax: 0.1,
            size: [0.9, 1.7],
            tint: [148, 163, 184],
            baseAlpha: 0.42,
            twinkle: 1.2,
          },
          {
            count: 76,
            speed: 26,
            parallax: 0.22,
            size: [0.7, 1.2],
            tint: [56, 189, 248],
            baseAlpha: 0.58,
            twinkle: 1.8,
          },
          {
            count: 110,
            speed: 46,
            parallax: 0.36,
            size: [0.4, 0.9],
            tint: [129, 140, 248],
            baseAlpha: 0.5,
            twinkle: 2.3,
          },
        ];

        state.backgroundLayers = layerConfigs.map((config) => {
          const [minSize, maxSize] = config.size;
          return {
            ...config,
            maxSize,
            stars: Array.from({ length: config.count }, () => ({
              x: Math.random() * state.width,
              y: Math.random() * state.height,
              size: minSize + Math.random() * (maxSize - minSize),
              phase: Math.random() * Math.PI * 2,
            })),
          };
        });

        state.nebulae = [
          {
            x: state.width * 0.24,
            y: state.height * 0.32,
            radius: 160,
            colors: [
              [58, 176, 255, 0.48],
              [14, 165, 233, 0.07],
            ],
            pulse: Math.random() * Math.PI * 2,
            pulseSpeed: 0.9,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: 0.16,
            floatSpeed: 0.32,
            strands: Array.from({ length: 4 }, () => ({
              offset: Math.random() * Math.PI * 2,
              radiusScale: 0.45 + Math.random() * 0.4,
              width: 0.45 + Math.random() * 0.35,
              drift: 0.4 + Math.random() * 0.6,
            })),
          },
          {
            x: state.width * 0.68,
            y: state.height * 0.2,
            radius: 200,
            colors: [
              [236, 72, 153, 0.4],
              [79, 70, 229, 0.12],
            ],
            pulse: Math.random() * Math.PI * 2,
            pulseSpeed: 0.7,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: -0.18,
            floatSpeed: 0.26,
            strands: Array.from({ length: 3 }, () => ({
              offset: Math.random() * Math.PI * 2,
              radiusScale: 0.52 + Math.random() * 0.35,
              width: 0.38 + Math.random() * 0.25,
              drift: 0.3 + Math.random() * 0.5,
            })),
          },
          {
            x: state.width * 0.78,
            y: state.height * 0.72,
            radius: 130,
            colors: [
              [129, 140, 248, 0.5],
              [56, 189, 248, 0.12],
            ],
            pulse: Math.random() * Math.PI * 2,
            pulseSpeed: 1.05,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: 0.22,
            floatSpeed: 0.44,
            strands: Array.from({ length: 3 }, () => ({
              offset: Math.random() * Math.PI * 2,
              radiusScale: 0.4 + Math.random() * 0.3,
              width: 0.42 + Math.random() * 0.28,
              drift: 0.45 + Math.random() * 0.55,
            })),
          },
        ];

        state.galaxies = [
          createGalaxy({
            x: state.width * 0.18,
            y: state.height * 0.2,
            radius: 130,
            arms: 3,
            tint: [94, 234, 212],
          }),
          createGalaxy({
            x: state.width * 0.74,
            y: state.height * 0.34,
            radius: 180,
            arms: 4,
            tint: [129, 140, 248],
          }),
          createGalaxy({
            x: state.width * 0.5,
            y: state.height * 0.78,
            radius: 110,
            arms: 2,
            tint: [56, 189, 248],
          }),
        ];

        state.lightStreaks = Array.from({ length: 12 }, () => createLightStreak());
      }

      function createGalaxy({ x, y, radius, arms = 3, tint }) {
        const starSamples = 90;
        const stars = [];
        for (let arm = 0; arm < arms; arm++) {
          const armOffset = (arm / arms) * Math.PI * 2;
          for (let i = 0; i < starSamples; i++) {
            const t = i / starSamples;
            const angle = armOffset + t * Math.PI * 2.1;
            const distance = radius * (0.18 + t * 0.95);
            stars.push({
              baseAngle: angle,
              distance: distance * (0.82 + Math.random() * 0.28),
              phase: Math.random() * Math.PI * 2,
              twinkle: 0.8 + Math.random() * 1.6,
              size: 0.6 + Math.random() * 1.8,
              spread: 0.55 + Math.random() * 0.35,
            });
          }
        }

        return {
          x,
          y,
          radius,
          arms,
          tint,
          stars,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.06,
          core: `rgba(${tint[0]}, ${tint[1]}, ${tint[2]}, 0.82)`,
          halo: `rgba(${tint[0]}, ${tint[1]}, ${tint[2]}, 0.12)`,
        };
      }

      function createLightStreak() {
        const angle = -Math.PI / 9 + (Math.random() - 0.5) * 0.22;
        const length = 90 + Math.random() * 160;
        return {
          x: Math.random() * state.width,
          y: Math.random() * state.height,
          angle,
          length,
          width: 1 + Math.random() * 1.5,
          speed: 26 + Math.random() * 42,
          parallax: 0.22 + Math.random() * 0.38,
          alpha: 0.12 + Math.random() * 0.22,
        };
      }

      function advanceCosmos(dt) {
        const drift = state.running ? state.pipeSpeed * 0.4 : 36;
        for (const layer of state.backgroundLayers) {
          const speed = layer.speed + drift * layer.parallax;
          for (const star of layer.stars) {
            star.x -= speed * dt;
            if (star.x < -layer.maxSize) {
              star.x = state.width + Math.random() * state.width * 0.25;
              star.y = Math.random() * state.height;
            }
            star.phase += dt * layer.twinkle;
          }
        }

        for (const nebula of state.nebulae) {
          nebula.pulse += dt * nebula.pulseSpeed;
          nebula.rotation += dt * nebula.rotationSpeed;
          for (const strand of nebula.strands) {
            strand.offset += dt * strand.drift;
          }
        }

        for (const galaxy of state.galaxies) {
          galaxy.rotation += dt * galaxy.rotationSpeed;
          for (const star of galaxy.stars) {
            star.phase += dt * star.twinkle;
          }
        }

        for (const streak of state.lightStreaks) {
          const baseSpeed = streak.speed + drift * streak.parallax;
          streak.x -= baseSpeed * dt;
          streak.y += Math.sin(streak.angle) * baseSpeed * 0.05 * dt;
          if (streak.x + Math.cos(streak.angle) * streak.length < -80) {
            Object.assign(streak, createLightStreak(), {
              x: state.width + Math.random() * state.width * 0.25,
            });
          }
        }
      }

      function renderCosmos(now) {
        const time = now * 0.001;
        const glow = ctx.createLinearGradient(0, 0, 0, state.height);
        glow.addColorStop(0, "#040a1d");
        glow.addColorStop(1, "#01030d");
        ctx.fillStyle = glow;
        ctx.fillRect(0, 0, state.width, state.height);

        ctx.save();
        ctx.globalCompositeOperation = "screen";
        for (const galaxy of state.galaxies) {
          ctx.save();
          ctx.translate(galaxy.x, galaxy.y);
          ctx.rotate(galaxy.rotation);
          const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, galaxy.radius);
          coreGradient.addColorStop(0, "rgba(255, 255, 255, 0.9)");
          coreGradient.addColorStop(0.35, galaxy.core);
          coreGradient.addColorStop(1, galaxy.halo);
          ctx.fillStyle = coreGradient;
          ctx.beginPath();
          ctx.ellipse(0, 0, galaxy.radius, galaxy.radius * 0.68, 0, 0, Math.PI * 2);
          ctx.fill();

          for (const star of galaxy.stars) {
            const oscillation = Math.sin(star.phase);
            const angle = star.baseAngle + Math.sin(star.phase * 0.5) * 0.12;
            const distance = star.distance * (0.92 + Math.sin(star.phase * 0.3) * 0.1);
            const sx = Math.cos(angle) * distance;
            const sy = Math.sin(angle) * distance * star.spread;
            const alpha = 0.18 + Math.abs(oscillation) * 0.32;
            const size = star.size * (0.7 + Math.abs(oscillation) * 0.4);
            ctx.fillStyle = `rgba(${galaxy.tint[0]}, ${galaxy.tint[1]}, ${galaxy.tint[2]}, ${alpha})`;
            ctx.beginPath();
            ctx.ellipse(sx, sy, size, size * 0.75, angle, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }
        ctx.restore();

        for (const nebula of state.nebulae) {
          ctx.save();
          const floatY = nebula.y + Math.sin(time * nebula.floatSpeed) * 18;
          ctx.translate(nebula.x, floatY);
          ctx.rotate(nebula.rotation);
          const energy = 0.6 + Math.sin(nebula.pulse) * 0.25;
          const baseRadius = nebula.radius * (0.92 + Math.sin(nebula.pulse * 0.7) * 0.06);
          const [inner, outer] = nebula.colors;
          const gradient = ctx.createRadialGradient(0, 0, baseRadius * 0.15, 0, 0, baseRadius);
          gradient.addColorStop(
            0,
            `rgba(${inner[0]}, ${inner[1]}, ${inner[2]}, ${(inner[3] || 0.4) * energy})`
          );
          gradient.addColorStop(
            1,
            `rgba(${outer[0]}, ${outer[1]}, ${outer[2]}, ${(outer[3] || 0.1) * energy})`
          );
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.ellipse(0, 0, baseRadius * 1.25, baseRadius * 0.95, 0, 0, Math.PI * 2);
          ctx.fill();

          ctx.globalCompositeOperation = "lighter";
          for (const strand of nebula.strands) {
            const radius = baseRadius * (strand.radiusScale + 0.3);
            const start = strand.offset;
            const end = start + Math.PI * 0.6;
            ctx.lineWidth = baseRadius * 0.12 * strand.width * energy;
            ctx.strokeStyle = `rgba(56, 189, 248, ${0.06 * energy})`;
            ctx.beginPath();
            ctx.arc(0, 0, radius, start, end);
            ctx.stroke();
          }
          ctx.restore();
        }

        for (const layer of state.backgroundLayers) {
          ctx.save();
          for (const star of layer.stars) {
            const twinkle = 0.6 + Math.sin(star.phase + time * 3.2) * 0.4;
            const [r, g, b] = layer.tint;
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${layer.baseAlpha * twinkle})`;
            const renderSize = star.size * (1 + Math.sin(star.phase * 2) * 0.25);
            ctx.beginPath();
            ctx.arc(star.x, star.y, renderSize, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        ctx.save();
        ctx.globalCompositeOperation = "screen";
        for (const streak of state.lightStreaks) {
          const endX = streak.x + Math.cos(streak.angle) * streak.length;
          const endY = streak.y + Math.sin(streak.angle) * streak.length;
          const gradient = ctx.createLinearGradient(streak.x, streak.y, endX, endY);
          gradient.addColorStop(0, "rgba(148, 163, 184, 0)");
          gradient.addColorStop(0.4, `rgba(56, 189, 248, ${streak.alpha})`);
          gradient.addColorStop(1, "rgba(148, 163, 184, 0)");
          ctx.strokeStyle = gradient;
          ctx.lineWidth = streak.width;
          ctx.beginPath();
          ctx.moveTo(streak.x, streak.y);
          ctx.lineTo(endX, endY);
          ctx.stroke();
        }
        ctx.restore();
      }

      function addTrailPoint(widthScale = 1) {
        const speedDelta = Math.max(0, state.pipeSpeed - 190);
        const speedFactor = 1 + Math.min(0.9, speedDelta / 220);
        const baseX = state.bird.x - state.bird.radius * (0.65 + widthScale * 0.08);
        const baseY = state.bird.y + state.bird.velocity * 0.025;
        const maxLife = 0.42 + Math.min(0.55, widthScale * 0.24) + speedFactor * 0.18;
        state.trail.unshift({
          x: baseX,
          y: baseY,
          age: 0,
          maxLife,
          width: (8 + widthScale * 6) * speedFactor,
          glow: 0.22 + widthScale * 0.18,
          vx: -(85 + state.pipeSpeed * 0.5) * (0.9 + widthScale * 0.08),
          vy: -state.bird.velocity * 0.1,
        });
        const maxSegments = 70 + Math.floor(Math.min(42, speedDelta * 0.25));
        if (state.trail.length > maxSegments) {
          state.trail.length = maxSegments;
        }
      }

      function burstTrail(strength = 1) {
        state.trailBoost = Math.min(1.6, state.trailBoost + strength * 0.6);
        for (let i = 0; i < 6; i++) {
          addTrailPoint(1 + strength * 0.4);
        }
      }

      function updateTrail(dt, emissionScale) {
        state.trailBoost = Math.max(0, state.trailBoost - dt * 1.8);
        const intensity = Math.max(0, emissionScale) + state.trailBoost;
        const emitRate = 0.9 + intensity * 2.4;
        state.trailCooldown += dt * emitRate;
        const interval = 0.015;
        while (state.trailCooldown >= interval) {
          addTrailPoint(1 + intensity * 0.35);
          state.trailCooldown -= interval;
        }

        for (const segment of state.trail) {
          segment.age += dt;
          segment.x += segment.vx * dt;
          segment.y += segment.vy * dt;
          segment.vx *= 0.985;
          segment.vy *= 0.94;
        }
        state.trail = state.trail.filter((segment) => segment.age < segment.maxLife);
      }

      function renderTrail() {
        if (state.trail.length < 2) return;
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.lineCap = "round";

        for (let i = 0; i < state.trail.length - 1; i++) {
          const current = state.trail[i];
          const next = state.trail[i + 1];
          const progress = current.age / current.maxLife;
          if (progress >= 1) continue;
          const width = Math.max(1.2, current.width * (1 - progress));
          const glow = current.glow * (1 - progress);
          const gradient = ctx.createLinearGradient(current.x, current.y, next.x, next.y);
          gradient.addColorStop(0, "rgba(14, 165, 233, 0)");
          gradient.addColorStop(0.45, `rgba(56, 189, 248, ${glow})`);
          gradient.addColorStop(1, "rgba(250, 204, 21, 0)");
          ctx.strokeStyle = gradient;
          ctx.lineWidth = width;
          ctx.beginPath();
          ctx.moveTo(current.x, current.y);
          ctx.lineTo(next.x, next.y);
          ctx.stroke();

          ctx.strokeStyle = `rgba(255, 255, 255, ${glow * 0.35})`;
          ctx.lineWidth = width * 0.45;
          ctx.beginPath();
          ctx.moveTo(current.x, current.y);
          ctx.lineTo(next.x, next.y);
          ctx.stroke();
        }

        ctx.restore();
      }

      function startShake(intensity = 6, duration = 0.3) {
        state.shake.intensity = Math.max(intensity, state.shake.intensity * 0.6);
        state.shake.duration = Math.max(duration, state.shake.duration * 0.6);
        state.shake.elapsed = 0;
      }

      function updateShake(dt) {
        if (state.shake.elapsed < state.shake.duration) {
          state.shake.elapsed += dt;
        }
      }

      function getShakeOffset(now) {
        if (state.shake.elapsed >= state.shake.duration) {
          return { x: 0, y: 0 };
        }
        const progress = state.shake.elapsed / state.shake.duration;
        const damping = (1 - progress) * (1 - progress);
        const time = now * 0.001;
        const offsetX = Math.sin(time * 90 + state.shake.elapsed * 120) * state.shake.intensity * damping;
        const offsetY = Math.cos(time * 70 + state.shake.elapsed * 150) * state.shake.intensity * damping;
        return { x: offsetX, y: offsetY };
      }

      initializeCosmos();

      function formatScore(value) {
        return value.toString().padStart(3, "0");
      }

      function updateHud() {
        scoreEl.textContent = formatScore(Math.floor(state.score));
        bestEl.textContent = `BEST ${formatScore(Math.floor(state.best))}`;
        if (!state.running) {
          statusEl.textContent = state.gameOver ? "Tap to respawn" : "Stay between the gates";
          hintEl.textContent = state.gameOver ? "Space or tap to try again" : "Tap or press space to boost";
        } else {
          statusEl.textContent = `x${state.multiplier.toFixed(1)} speed`; 
        }
      }

      function resetGame() {
        state.running = false;
        state.gameOver = false;
        state.bird.y = state.height / 2;
        state.bird.velocity = 0;
        state.bird.wobble = 0;
        state.pipes = [];
        state.score = 0;
        state.multiplier = 1;
        state.timeSincePipe = 0;
        state.pipeGap = 180;
        state.pipeSpeed = 190;
        state.lastSpawnY = state.height / 2;
        state.trail = [];
        state.trailCooldown = 0;
        state.trailBoost = 0;
        state.shake.elapsed = 1;
        state.shake.duration = 0;
        state.shake.intensity = 0;
        updateHud();
        draw(0);
      }

      function spawnPipe() {
        const margin = 80;
        const center = Math.max(
          margin + state.pipeGap / 2,
          Math.min(state.height - margin - state.pipeGap / 2, state.lastSpawnY + (Math.random() * 120 - 60))
        );
        state.lastSpawnY = center;
        state.pipes.push({
          x: state.width + 60,
          width: 80,
          gapCenter: center,
          passed: false,
        });
      }

      function flap() {
        if (state.gameOver) {
          resetGame();
          state.running = true;
          burstTrail(1.4);
          updateHud();
          return;
        }
        if (!state.running) {
          state.running = true;
          state.timeSincePipe = state.pipeSpacing;
          updateHud();
        }
        state.bird.velocity = state.jump;
        state.bird.wobble = 0.5;
        burstTrail(0.9 + Math.min(0.6, state.multiplier * 0.08));
      }

      function update(dt) {
        advanceCosmos(dt);
        updateShake(dt);
        if (!state.running) {
          state.bird.wobble += dt * 2.8;
          state.bird.y = state.height / 2 + Math.sin(state.bird.wobble) * 12;
          updateTrail(dt, 0.25);
          return;
        }

        state.timeSincePipe += dt;
        if (state.timeSincePipe >= state.pipeSpacing) {
          spawnPipe();
          state.timeSincePipe = 0;
          state.pipeSpacing = Math.max(1.05, state.pipeSpacing * 0.985);
          state.pipeGap = Math.max(120, state.pipeGap * 0.992);
          state.pipeSpeed = Math.min(320, state.pipeSpeed + 2);
        }

        state.bird.velocity += state.gravity * dt;
        state.bird.y += state.bird.velocity * dt;

        for (const pipe of state.pipes) {
          pipe.x -= state.pipeSpeed * dt;
          if (!pipe.passed && pipe.x + pipe.width < state.bird.x - state.bird.radius) {
            pipe.passed = true;
            state.score += 1 * state.multiplier;
            state.multiplier = Math.min(9, state.multiplier + 0.15);
            updateHud();
          }
        }

        if (state.pipes.length && state.pipes[0].x + state.pipes[0].width < -10) {
          state.pipes.shift();
        }

        const topLimit = state.bird.radius + 4;
        const bottomLimit = state.height - state.bird.radius - 4;
        if (state.bird.y < topLimit || state.bird.y > bottomLimit) {
          startShake(7, 0.32);
          triggerGameOver();
        }

        for (const pipe of state.pipes) {
          const halfGap = state.pipeGap / 2;
          const topPipeBottom = pipe.gapCenter - halfGap;
          const bottomPipeTop = pipe.gapCenter + halfGap;
          const birdLeft = state.bird.x - state.bird.radius + 6;
          const birdRight = state.bird.x + state.bird.radius - 6;
          if (birdRight > pipe.x && birdLeft < pipe.x + pipe.width) {
            if (state.bird.y - state.bird.radius < topPipeBottom || state.bird.y + state.bird.radius > bottomPipeTop) {
              startShake(10, 0.45);
              triggerGameOver();
              break;
            }
          }
        }

        updateTrail(dt, 0.9 + Math.min(0.8, state.multiplier * 0.15));
      }

      function triggerGameOver() {
        if (state.gameOver) return;
        state.gameOver = true;
        state.running = false;
        state.best = Math.max(state.best, state.score);
        state.multiplier = 1;
        updateHud();
      }

      function draw(now) {
        renderCosmos(now);

        const shakeOffset = getShakeOffset(now);
        ctx.save();
        ctx.translate(shakeOffset.x, shakeOffset.y);

        // Pipes
        for (const pipe of state.pipes) {
          const halfGap = state.pipeGap / 2;
          const topHeight = pipe.gapCenter - halfGap;
          const bottomY = pipe.gapCenter + halfGap;
          const gradTop = ctx.createLinearGradient(pipe.x, 0, pipe.x + pipe.width, 0);
          gradTop.addColorStop(0, "#6366f1");
          gradTop.addColorStop(1, "#38bdf8");
          ctx.fillStyle = gradTop;
          ctx.fillRect(pipe.x, 0, pipe.width, topHeight);

          const gradBottom = ctx.createLinearGradient(pipe.x, bottomY, pipe.x + pipe.width, bottomY + 20);
          gradBottom.addColorStop(0, "#38bdf8");
          gradBottom.addColorStop(1, "#22d3ee");
          ctx.fillStyle = gradBottom;
          ctx.fillRect(pipe.x, bottomY, pipe.width, state.height - bottomY);

          ctx.fillStyle = "rgba(94, 234, 212, 0.3)";
          ctx.fillRect(pipe.x - 6, topHeight - 12, pipe.width + 12, 12);
          ctx.fillRect(pipe.x - 6, bottomY, pipe.width + 12, 12);
        }

        renderTrail();

        // Bird
        ctx.save();
        ctx.translate(state.bird.x, state.bird.y);
        const tilt = Math.max(-0.45, Math.min(0.65, state.bird.velocity / 420));
        ctx.rotate(tilt);
        const wingFlap = state.running ? Math.sin(now * 0.02) : Math.sin(now * 0.01);
        ctx.fillStyle = "#facc15";
        ctx.beginPath();
        ctx.ellipse(0, 0, state.bird.radius + 4, state.bird.radius, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#f97316";
        ctx.beginPath();
        ctx.moveTo(state.bird.radius + 2, -4);
        ctx.lineTo(state.bird.radius + 18, 0);
        ctx.lineTo(state.bird.radius + 2, 4);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "rgba(248, 250, 252, 0.9)";
        ctx.beginPath();
        ctx.arc(8, -6, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#1e293b";
        ctx.beginPath();
        ctx.arc(10, -6, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "rgba(14, 165, 233, 0.65)";
        ctx.beginPath();
        ctx.ellipse(-6, 10 + wingFlap * 4, 16, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        ctx.restore();

        if (state.gameOver) {
          ctx.fillStyle = "rgba(2, 6, 23, 0.6)";
          ctx.fillRect(0, state.height / 2 - 70, state.width, 140);
          ctx.fillStyle = "#f8fafc";
          ctx.textAlign = "center";
          ctx.font = "bold 32px 'Space Grotesk', sans-serif";
          ctx.fillText("Run Ended", state.width / 2, state.height / 2 - 18);
          ctx.font = "20px 'Space Grotesk', sans-serif";
          ctx.fillText("Score: " + Math.floor(state.score), state.width / 2, state.height / 2 + 14);
          ctx.fillStyle = "#38bdf8";
          ctx.font = "16px 'Space Grotesk', sans-serif";
          ctx.fillText("Tap or press space", state.width / 2, state.height / 2 + 46);
        }
      }

      let lastTime = performance.now();
      function loop(now) {
        const dt = Math.min((now - lastTime) / 1000, 0.1);
        lastTime = now;
        update(dt);
        draw(now);
        requestAnimationFrame(loop);
      }

      resetGame();
      requestAnimationFrame(loop);
      updateHud();

      const hostDocument = root.host?.ownerDocument || document;

      function onPointerDown(event) {
        event.preventDefault();
        flap();
      }

      function onKeyDown(event) {
        if (event.code === "Space" || event.code === "ArrowUp") {
          event.preventDefault();
          flap();
        }
      }

      root.addEventListener("pointerdown", onPointerDown);
      hostDocument.addEventListener("keydown", onKeyDown);

      if (!root.__sandboxCleanup) {
        root.__sandboxCleanup = [];
      }

      root.__sandboxCleanup.push(() => {
        root.removeEventListener("pointerdown", onPointerDown);
        hostDocument.removeEventListener("keydown", onKeyDown);
      });
    </script>
  </body>
</html>
