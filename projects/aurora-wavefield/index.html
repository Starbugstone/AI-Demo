<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Aurora Wavefield</title>
    <style>
      :host {
        display: block;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
        color: #e2e8f0;
      }

      body {
        margin: 0;
        padding: 0;
        background: transparent;
      }

      .shell {
        display: grid;
        gap: clamp(1rem, 2vw, 1.25rem);
        padding: clamp(1.25rem, 2.5vw, 1.6rem);
        border-radius: 1.5rem;
        border: 1px solid rgba(147, 197, 253, 0.35);
        background: linear-gradient(145deg, rgba(15, 118, 110, 0.16), rgba(59, 130, 246, 0.08)),
          rgba(15, 23, 42, 0.82);
        box-shadow: 0 1.5rem 3rem rgba(2, 6, 23, 0.6);
        width: 100%;
        min-height: 100%;
        box-sizing: border-box;
        grid-template-rows: auto minmax(0, 1fr) auto;
      }

      header {
        max-width: 72ch;
      }

      header h2 {
        margin: 0 0 0.4rem;
        font-size: 1.4rem;
        letter-spacing: 0.14em;
        text-transform: uppercase;
      }

      header p {
        margin: 0;
        max-width: 72ch;
        color: rgba(191, 219, 254, 0.85);
        line-height: 1.6;
      }

      canvas {
        width: 100%;
        height: auto;
        aspect-ratio: 5 / 3;
        border-radius: 1.4rem;
        display: block;
      }

      footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 0.75rem;
        max-width: 72ch;
        font-size: 0.85rem;
        color: rgba(148, 163, 184, 0.85);
      }

      .legend {
        display: inline-flex;
        gap: 0.75rem;
        align-items: center;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .legend span::before {
        content: "";
        display: inline-block;
        width: 0.5rem;
        height: 0.5rem;
        border-radius: 999px;
        background: currentColor;
        margin-right: 0.3rem;
        opacity: 0.7;
      }
    </style>
  </head>
  <body>
    <section class="shell" role="presentation">
      <header>
        <h2>Aurora Wavefield</h2>
        <p>
          Blended ribbons glide in procedural harmony. Move your cursor to bend the wave crests and dial up
          the shimmer.
        </p>
      </header>
      <canvas id="aurora-stage"></canvas>
      <footer>
        <div class="legend">
          <span>Amplitude Mod</span>
          <span>Phase Drift</span>
        </div>
        <span>Tip: Hold the pointer steady to let the aurora settle into a resonant pattern.</span>
      </footer>
    </section>

    <script>
      const root = document.currentScript.getRootNode();
      const hostDocument = root.host?.ownerDocument || root;
      const defaultView = hostDocument.defaultView;
      const canvas = root.getElementById('aurora-stage');
      const ctx = canvas.getContext('2d');

      const DPR = window.devicePixelRatio || 1;
      const state = {
        width: 680,
        height: 408,
      };

      const layers = Array.from({ length: 5 }, (_, index) => ({
        phase: Math.random() * Math.PI * 2,
        amplitude: 60 + index * 18,
        hue: 170 + index * 35,
      }));

      const pointer = {
        active: false,
        x: state.width / 2,
        y: state.height / 2,
        influence: 0,
      };

      const resize = () => {
        const rect = canvas.getBoundingClientRect();
        state.width = rect.width;
        state.height = rect.height;
        canvas.width = rect.width * DPR;
        canvas.height = rect.height * DPR;
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      };

      const startGradient = (layer, opacity) => {
        const gradient = ctx.createLinearGradient(0, 0, state.width, state.height);
        gradient.addColorStop(0, `hsla(${layer.hue}, 95%, 68%, ${opacity})`);
        gradient.addColorStop(0.5, `hsla(${layer.hue + 40}, 95%, 74%, ${opacity * 0.7})`);
        gradient.addColorStop(1, `hsla(${layer.hue + 80}, 90%, 78%, ${opacity * 0.45})`);
        return gradient;
      };

      const drawLayer = (layer, time) => {
        ctx.beginPath();
        const baseline = state.height * 0.35 + Math.sin(time * 0.3 + layer.phase) * 20;
        const frequency = 2.2 + Math.sin(time * 0.17 + layer.phase) * 0.4;
        const density = pointer.active ? 140 : 110;
        const amplitude = layer.amplitude + pointer.influence * 65;

        for (let x = 0; x <= state.width; x += state.width / density) {
          const progress = x / state.width;
          const wave = Math.sin(progress * Math.PI * frequency + layer.phase + time * 0.9);
          const offset = Math.sin(progress * 6 + time * 1.2) * amplitude * 0.15;
          const focus = pointer.active
            ? Math.exp(-Math.pow((x - pointer.x) / (state.width * 0.18), 2)) * pointer.influence * 48
            : 0;
          const y = baseline + wave * amplitude + offset + focus;
          ctx.lineTo(x, y);
        }

        ctx.lineTo(state.width, state.height);
        ctx.lineTo(0, state.height);
        ctx.closePath();

        ctx.fillStyle = startGradient(layer, 0.25);
        ctx.fill();

        ctx.strokeStyle = startGradient(layer, 0.55);
        ctx.lineWidth = 1.8;
        ctx.stroke();
      };

      let lastTimestamp = performance.now();
      let frameCount = 0;
      let accumulator = 0;

      const render = (timestamp) => {
        const delta = timestamp - lastTimestamp;
        lastTimestamp = timestamp;
        accumulator += delta;
        frameCount += 1;

        const time = timestamp * 0.0012;

        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(3, 6, 18, 0.35)';
        ctx.fillRect(0, 0, state.width, state.height);

        ctx.globalCompositeOperation = 'lighter';
        layers.forEach((layer, index) => {
          layer.phase += 0.004 + index * 0.0015;
          drawLayer(layer, time + index * 0.15);
        });

        if (pointer.active) {
          const radial = ctx.createRadialGradient(pointer.x, pointer.y, 0, pointer.x, pointer.y, 180);
          radial.addColorStop(0, 'rgba(165, 243, 252, 0.18)');
          radial.addColorStop(1, 'rgba(165, 243, 252, 0)');
          ctx.globalCompositeOperation = 'screen';
          ctx.fillStyle = radial;
          ctx.beginPath();
          ctx.arc(pointer.x, pointer.y, 180, 0, Math.PI * 2);
          ctx.fill();
        }

        requestAnimationFrame(render);
      };

      const updatePointer = (event) => {
        const rect = canvas.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * state.width;
        pointer.y = ((event.clientY - rect.top) / rect.height) * state.height;
        pointer.influence = Math.min(1, Math.max(0.1, 1 - pointer.y / state.height));
      };

      canvas.addEventListener('pointerdown', (event) => {
        pointer.active = true;
        updatePointer(event);
        canvas.setPointerCapture(event.pointerId);
      });

      canvas.addEventListener('pointermove', (event) => {
        if (!pointer.active) return;
        updatePointer(event);
      });

      const releasePointer = () => {
        pointer.active = false;
        pointer.influence = 0;
      };

      canvas.addEventListener('pointerup', releasePointer);
      canvas.addEventListener('pointercancel', releasePointer);

      resize();
      requestAnimationFrame(render);

      const observer = new ResizeObserver(() => resize());
      observer.observe(canvas);

      defaultView?.addEventListener('resize', resize);

      hostDocument.addEventListener('visibilitychange', () => {
        if (hostDocument.hidden) {
          pointer.active = false;
          pointer.influence = 0;
        }
      });
    </script>
  </body>
</html>
