<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Pipe Mania: Coolant Cascade</title>
    <style>
      :host {
        font-family: "Russo One", "Bebas Neue", "Segoe UI", sans-serif;
        color: #e2e8f0;
        background: transparent;
        display: block;
        padding: clamp(1rem, 2vw + 1rem, 2.5rem);
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: transparent;
      }

      .wrapper {
        max-width: 1080px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
      }

      header h1 {
        margin: 0;
        font-size: clamp(1.6rem, 2vw + 1.4rem, 3rem);
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: #f8fafc;
      }

      .subtitle {
        margin: 0.35rem 0 0;
        color: rgba(148, 163, 184, 0.9);
        letter-spacing: 0.14em;
        text-transform: uppercase;
        font-size: 0.8rem;
      }

      .hud {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.8rem;
      }

      .stat {
        border-radius: 1rem;
        padding: 0.85rem 1rem;
        background: linear-gradient(145deg, rgba(15, 23, 42, 0.92), rgba(30, 41, 59, 0.65));
        box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.12), 0 16px 36px rgba(2, 8, 23, 0.55);
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .stat .label {
        font-size: 0.72rem;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: rgba(148, 163, 184, 0.75);
      }

      .stat .value {
        font-size: 1.4rem;
        letter-spacing: 0.05em;
        color: #f8fafc;
      }

      .timer-bar {
        position: relative;
        width: 100%;
        height: 0.4rem;
        margin-top: 0.5rem;
        border-radius: 999px;
        background: rgba(51, 65, 85, 0.4);
        overflow: hidden;
      }

      .timer-bar span {
        display: block;
        height: 100%;
        background: linear-gradient(90deg, #facc15, #f97316, #ef4444);
        transform-origin: left center;
        transition: transform 160ms ease-out;
      }

      .message {
        margin: 0;
        padding: 0.85rem 1rem;
        border-radius: 0.9rem;
        background: linear-gradient(140deg, rgba(8, 47, 73, 0.6), rgba(14, 165, 233, 0.1));
        box-shadow: inset 0 0 0 1px rgba(125, 211, 252, 0.18);
        min-height: 3.1rem;
        display: flex;
        align-items: center;
        font-size: 0.95rem;
        line-height: 1.45;
      }

      .message[data-tone="success"] {
        background: linear-gradient(135deg, rgba(22, 163, 74, 0.35), rgba(16, 185, 129, 0.18));
        box-shadow: inset 0 0 0 1px rgba(74, 222, 128, 0.4);
        color: #bbf7d0;
      }

      .message[data-tone="danger"] {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.35), rgba(190, 24, 93, 0.18));
        box-shadow: inset 0 0 0 1px rgba(248, 113, 113, 0.45);
        color: #fee2e2;
      }

      .layout {
        display: grid;
        grid-template-columns: minmax(0, 1fr) minmax(220px, 280px);
        gap: 1.25rem;
        align-items: start;
      }

      .board-wrap {
        position: relative;
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 1.25rem;
        padding: clamp(0.75rem, 1.1vw, 1.1rem);
        background: radial-gradient(circle at 18% 16%, rgba(56, 189, 248, 0.12), transparent 58%),
          radial-gradient(circle at 82% 18%, rgba(14, 116, 144, 0.1), transparent 64%),
          linear-gradient(155deg, rgba(7, 11, 26, 0.95), rgba(10, 18, 34, 0.78));
        box-shadow: 0 35px 80px rgba(2, 8, 23, 0.72), inset 0 0 0 1px rgba(148, 163, 184, 0.15);
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
        border-radius: 0.9rem;
        background: linear-gradient(150deg, rgba(2, 6, 23, 0.96), rgba(15, 23, 42, 0.92));
        box-shadow: inset 0 0 60px rgba(59, 130, 246, 0.08);
      }

      aside.sidebar {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .panel {
        background: linear-gradient(145deg, rgba(15, 23, 42, 0.85), rgba(30, 41, 59, 0.55));
        border-radius: 1.1rem;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.12);
      }

      .panel h2 {
        margin: 0;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.18em;
        color: rgba(148, 163, 184, 0.9);
      }

      .queue {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .queue-item {
        display: grid;
        grid-template-columns: 72px 1fr;
        gap: 0.75rem;
        align-items: center;
        padding: 0.5rem 0.65rem;
        border-radius: 0.85rem;
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(71, 85, 105, 0.4);
        transition: border-color 160ms ease, transform 160ms ease;
      }

      .queue-item.active {
        border-color: rgba(45, 212, 191, 0.7);
        background: rgba(15, 118, 110, 0.22);
        transform: translateY(-2px);
      }

      .queue-item canvas {
        width: 72px;
        height: 72px;
        background: rgba(7, 11, 24, 0.65);
        border-radius: 0.7rem;
        box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.12);
      }

      .queue-item .meta {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .queue-item .title {
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #e0f2fe;
      }

      .queue-item .hint {
        font-size: 0.72rem;
        color: rgba(148, 163, 184, 0.75);
        line-height: 1.4;
      }

      .panel .instructions {
        font-size: 0.75rem;
        line-height: 1.5;
        color: rgba(148, 163, 184, 0.8);
      }

      .panel-controls {
        display: grid;
        gap: 0.65rem;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 0.85rem 1.6rem;
        text-transform: uppercase;
        letter-spacing: 0.18em;
        font-size: 0.7rem;
        font-weight: 700;
        cursor: pointer;
        color: #0f172a;
        transition: transform 160ms ease, box-shadow 160ms ease;
      }

      button.primary {
        background: linear-gradient(135deg, #22d3ee, #0ea5e9);
        box-shadow: 0 14px 38px rgba(14, 165, 233, 0.35);
      }

      button.secondary {
        background: linear-gradient(135deg, #f97316, #ef4444);
        box-shadow: 0 14px 38px rgba(248, 113, 113, 0.35);
      }

      .panel-controls button {
        width: 100%;
        background: linear-gradient(135deg, rgba(45, 212, 191, 0.65), rgba(14, 165, 233, 0.6));
        color: #022c22;
        box-shadow: 0 10px 24px rgba(13, 148, 136, 0.35);
      }

      .panel-controls button:nth-child(2) {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.7), rgba(56, 189, 248, 0.6));
        color: #041b33;
      }

      .panel-controls button:last-child {
        background: linear-gradient(135deg, rgba(248, 113, 113, 0.75), rgba(244, 63, 94, 0.65));
        color: #2b0a0f;
      }

      button:active {
        transform: translateY(1px) scale(0.99);
      }

      button:focus-visible {
        outline: 2px solid rgba(14, 165, 233, 0.75);
        outline-offset: 3px;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.85rem;
        justify-content: center;
        margin-top: 0.5rem;
      }

      @media (max-width: 960px) {
        .layout {
          grid-template-columns: 1fr;
        }

        aside.sidebar {
          order: -1;
        }
      }

      @media (max-width: 640px) {
        :host {
          padding: 1rem;
        }

        .queue-item {
          grid-template-columns: 56px 1fr;
          padding: 0.45rem 0.55rem;
        }

        .queue-item canvas {
          width: 56px;
          height: 56px;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Pipe Mania: Coolant Cascade</h1>
        <p class="subtitle">Queue, rotate, and drop conduits before the plasma surge ignites the grid.</p>
      </header>
      <section class="hud" aria-live="polite">
        <div class="stat">
          <span class="label">Level</span>
          <span class="value" id="level">1</span>
        </div>
        <div class="stat">
          <span class="label">Score</span>
          <span class="value" id="score">0</span>
        </div>
        <div class="stat">
          <span class="label">Pressure Surge</span>
          <span class="value" id="timer">--</span>
          <div class="timer-bar" aria-hidden="true">
            <span id="timer-progress" style="transform: scaleX(1)"></span>
          </div>
        </div>
        <div class="stat">
          <span class="label">Flow Integrity</span>
          <span class="value" id="integrity">0%</span>
        </div>
      </section>
      <p class="message" id="message">
        Place conduits from the queue on the grid. Left click empty cells to drop the highlighted piece. Right click placed pieces to rotate.
        Survive the coolant surge by connecting the intake to the drain.
      </p>
      <div class="layout">
        <div class="board-wrap">
          <canvas id="board" width="720" height="720">Your browser does not support canvas.</canvas>
        </div>
        <aside class="sidebar">
          <div class="panel">
            <h2>Upcoming Conduits</h2>
            <div id="queue" class="queue" aria-live="polite"></div>
            <p class="instructions">
              Highlighted piece is next. Rotate it, scrap it, or drop it onto the lattice. Shift + right click removes a placed piece but shaves time off the surge.
            </p>
          </div>
          <div class="panel panel-controls">
            <button id="rotate-left" type="button">Rotate Piece ⟲</button>
            <button id="rotate-right" type="button">Rotate Piece ⟳</button>
            <button id="scrap-piece" type="button">Scrap Piece (-2s)</button>
          </div>
        </aside>
      </div>
      <div class="controls">
        <button class="primary" id="force-flow" type="button">Release Coolant</button>
        <button class="secondary" id="new-level" type="button">Reset Grid</button>
      </div>
    </div>
    <script>
      (function () {
        const root = document.currentScript.getRootNode();
        if (root.__pipeCascadeCleanup) {
          root.__pipeCascadeCleanup.forEach((fn) => {
            try {
              fn();
            } catch (error) {
              console.error(error);
            }
          });
        }
        const cleanupCallbacks = [];
        root.__pipeCascadeCleanup = cleanupCallbacks;
        const registerCleanup = (fn) => cleanupCallbacks.push(fn);

        const canvas = root.getElementById('board');
        const ctx = canvas.getContext('2d');
        const levelEl = root.getElementById('level');
        const scoreEl = root.getElementById('score');
        const timerEl = root.getElementById('timer');
        const timerProgressEl = root.getElementById('timer-progress');
        const integrityEl = root.getElementById('integrity');
        const messageEl = root.getElementById('message');
        const queueEl = root.getElementById('queue');
        const rotateLeftBtn = root.getElementById('rotate-left');
        const rotateRightBtn = root.getElementById('rotate-right');
        const scrapBtn = root.getElementById('scrap-piece');
        const forceButton = root.getElementById('force-flow');
        const resetButton = root.getElementById('new-level');
        const boardWrap = root.querySelector('.board-wrap');

        const DIRS = [
          { dx: 0, dy: -1, bit: 1, oppositeBit: 4 },
          { dx: 1, dy: 0, bit: 2, oppositeBit: 8 },
          { dx: 0, dy: 1, bit: 4, oppositeBit: 1 },
          { dx: -1, dy: 0, bit: 8, oppositeBit: 2 },
        ];

        const PIECES = [
          { type: 'straight', baseMask: 1 | 4, label: 'Line' },
          { type: 'straight', baseMask: 2 | 8, label: 'Line' },
          { type: 'corner', baseMask: 1 | 2, label: 'Corner' },
          { type: 'corner', baseMask: 2 | 4, label: 'Corner' },
          { type: 'corner', baseMask: 4 | 8, label: 'Corner' },
          { type: 'corner', baseMask: 8 | 1, label: 'Corner' },
          { type: 'tee', baseMask: 1 | 2 | 4, label: 'T-Joint' },
          { type: 'tee', baseMask: 2 | 4 | 8, label: 'T-Joint' },
          { type: 'tee', baseMask: 1 | 4 | 8, label: 'T-Joint' },
          { type: 'tee', baseMask: 1 | 2 | 8, label: 'T-Joint' },
          { type: 'cross', baseMask: 1 | 2 | 4 | 8, label: 'Cross' },
          { type: 'cap', baseMask: 2, label: 'Cap' },
          { type: 'cap', baseMask: 8, label: 'Cap' },
          { type: 'cap', baseMask: 1, label: 'Cap' },
          { type: 'cap', baseMask: 4, label: 'Cap' },
        ];

        const QUEUE_SIZE = 5;
        const dpr = globalThis.devicePixelRatio || 1;

        const state = {
          gridSize: 9,
          board: [],
          queue: [],
          start: null,
          goal: null,
          level: 1,
          score: 0,
          integrity: 0,
          countdownRemaining: 22,
          timerId: null,
          pendingTimeouts: [],
          phase: 'build',
          flowActive: false,
          failureCell: null,
          lastFailureReason: '',
          shimmerSeed: Math.random() * 360,
          animationFrame: null,
          targetPathLength: 12,
          scrapPenalty: 2,
          initialCountdown: 22,
        };

        function randomInt(max) {
          return Math.floor(Math.random() * max);
        }

        function rotateMask(mask, rotation) {
          let result = mask;
          for (let i = 0; i < rotation; i += 1) {
            let next = 0;
            if (result & 1) next |= 2;
            if (result & 2) next |= 4;
            if (result & 4) next |= 8;
            if (result & 8) next |= 1;
            result = next;
          }
          return result;
        }

        function bitsFromMask(mask) {
          const bits = [];
          if (mask & 1) bits.push(1);
          if (mask & 2) bits.push(2);
          if (mask & 4) bits.push(4);
          if (mask & 8) bits.push(8);
          return bits;
        }

        function tileMask(tile) {
          if (!tile) return 0;
          return rotateMask(tile.baseMask, tile.rotation % 4);
        }

        function createTile(piece, overrides = {}) {
          return {
            type: piece.type,
            baseMask: piece.baseMask,
            rotation: overrides.rotation ?? piece.rotation ?? 0,
            locked: overrides.locked ?? false,
            wetProgress: overrides.wetProgress ?? 0,
            pulse: overrides.pulse ?? 0,
            special: overrides.special ?? null,
          };
        }

        function pushTimeout(fn, delay) {
          const id = setTimeout(() => {
            state.pendingTimeouts = state.pendingTimeouts.filter((stored) => stored !== id);
            fn();
          }, delay);
          state.pendingTimeouts.push(id);
          return id;
        }

        function clearPendingTimeouts() {
          state.pendingTimeouts.forEach((id) => clearTimeout(id));
          state.pendingTimeouts = [];
        }

        function stopCountdown() {
          if (state.timerId !== null) {
            clearInterval(state.timerId);
            state.timerId = null;
          }
        }

        function setMessage(text, tone = 'info') {
          messageEl.textContent = text;
          messageEl.dataset.tone = tone;
        }

        function adjustCountdown(amount) {
          state.countdownRemaining = Math.max(0, Math.round(state.countdownRemaining + amount));
          updateHud();
        }

        function updateHud() {
          levelEl.textContent = state.level;
          scoreEl.textContent = state.score;
          integrityEl.textContent = `${Math.round(state.integrity * 100)}%`;
          if (state.phase === 'flow') {
            timerEl.textContent = 'Flowing';
            timerProgressEl.style.transform = 'scaleX(0)';
          } else if (state.phase === 'win') {
            timerEl.textContent = 'Stabilized';
            timerProgressEl.style.transform = 'scaleX(0)';
          } else {
            timerEl.textContent = `${state.countdownRemaining}s`;
            const normalized = Math.min(1, Math.max(0, state.countdownRemaining / state.initialCountdown));
            timerProgressEl.style.transform = `scaleX(${normalized})`;
          }
        }

        function resetWetness() {
          for (let y = 0; y < state.gridSize; y += 1) {
            for (let x = 0; x < state.gridSize; x += 1) {
              const tile = state.board[y][x];
              if (!tile) continue;
              tile.wetProgress = 0;
            }
          }
        }

        function clearFlowState() {
          state.flowActive = false;
          state.failureCell = null;
          state.lastFailureReason = '';
          resetWetness();
        }

        function drawTileInContext(context, tile, x, y, size, timestamp, opts = {}) {
          const background = tile ? 'rgba(15, 23, 42, 0.92)' : 'rgba(8, 15, 28, 0.85)';
          context.fillStyle = background;
          context.fillRect(x, y, size, size);
          context.strokeStyle = 'rgba(100, 116, 139, 0.18)';
          context.lineWidth = 1;
          context.strokeRect(x + 0.5, y + 0.5, size - 1, size - 1);
          if (!tile) {
            if (opts.failureMatch) {
              context.strokeStyle = 'rgba(248, 113, 113, 0.82)';
              context.lineWidth = 2.5;
              context.strokeRect(x + 2, y + 2, size - 4, size - 4);
            }
            return;
          }
          const connectors = bitsFromMask(tileMask(tile));
          const cx = x + size / 2;
          const cy = y + size / 2;
          const radius = size * 0.18;
          const shimmer = Math.sin((timestamp / 180 + (x + y) * 0.09 + state.shimmerSeed) % (Math.PI * 2));
          const wetColor = `rgba(${24 + shimmer * 18}, ${209 + shimmer * 20}, ${245 + shimmer * 8}, 1)`;
          const idleColor = 'rgba(56, 189, 248, 0.95)';
          const lockedColor = 'rgba(248, 191, 22, 0.95)';
          const failureColor = 'rgba(248, 113, 113, 0.9)';
          const highlightFailure = opts.failureMatch ?? false;
          const fillColor = highlightFailure ? failureColor : tile.special ? lockedColor : tile.wetProgress > 0 ? wetColor : idleColor;

          if (tile.pulse > 0 && !opts.skipPulseFade) {
            const glow = Math.min(1, tile.pulse);
            const gradient = context.createRadialGradient(cx, cy, radius * 0.9, cx, cy, radius * 3.1);
            gradient.addColorStop(0, 'rgba(56, 189, 248, 0.45)');
            gradient.addColorStop(1, 'rgba(13, 148, 136, 0)');
            context.fillStyle = gradient;
            context.fillRect(x, y, size, size);
            tile.pulse = Math.max(0, tile.pulse - 0.04);
          } else if (!opts.skipPulseFade && tile.pulse > 0) {
            tile.pulse = Math.max(0, tile.pulse - 0.04);
          }

          context.strokeStyle = 'rgba(15, 23, 42, 0.65)';
          context.lineWidth = 1.5;
          context.strokeRect(x + 1.2, y + 1.2, size - 2.4, size - 2.4);

          context.lineWidth = size * 0.26;
          context.lineCap = 'round';
          connectors.forEach((bit) => {
            const dir = DIRS.find((entry) => entry.bit === bit);
            if (!dir) return;
            const length = size / 2 - radius;
            const startX = cx + dir.dx * (radius * 0.18);
            const startY = cy + dir.dy * (radius * 0.18);
            const endX = cx + dir.dx * length;
            const endY = cy + dir.dy * length;
            context.strokeStyle = fillColor;
            context.beginPath();
            context.moveTo(startX, startY);
            context.lineTo(endX, endY);
            context.stroke();
          });

          context.fillStyle = fillColor;
          context.beginPath();
          context.arc(cx, cy, radius * (1 + tile.wetProgress * 0.25), 0, Math.PI * 2);
          context.fill();

          if (tile.special === 'start') {
            context.fillStyle = 'rgba(249, 115, 22, 0.95)';
            context.beginPath();
            context.moveTo(x + size * 0.2, y + size * 0.32);
            context.lineTo(x + size * 0.2, y + size * 0.68);
            context.lineTo(x + size * 0.42, y + size * 0.5);
            context.closePath();
            context.fill();
          } else if (tile.special === 'goal') {
            context.fillStyle = 'rgba(16, 185, 129, 0.95)';
            context.fillRect(x + size * 0.58, y + size * 0.32, size * 0.18, size * 0.36);
          }
        }

        function drawBoard(timestamp = performance.now()) {
          const rect = canvas.getBoundingClientRect();
          const width = rect.width;
          const height = rect.height;
          ctx.clearRect(0, 0, width, height);
          const tileSize = width / state.gridSize;
          for (let y = 0; y < state.gridSize; y += 1) {
            for (let x = 0; x < state.gridSize; x += 1) {
              const tile = state.board[y][x];
              const failureMatch = state.failureCell && state.failureCell.x === x && state.failureCell.y === y;
              drawTileInContext(ctx, tile, x * tileSize, y * tileSize, tileSize, timestamp, { failureMatch });
            }
          }
          ctx.strokeStyle = 'rgba(15, 118, 110, 0.35)';
          ctx.lineWidth = 1;
          for (let i = 1; i < state.gridSize; i += 1) {
            const pos = i * tileSize;
            ctx.beginPath();
            ctx.moveTo(pos, 0);
            ctx.lineTo(pos, height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, pos);
            ctx.lineTo(width, pos);
            ctx.stroke();
          }
        }

        function drawQueue() {
          queueEl.innerHTML = '';
          const now = performance.now();
          state.queue.forEach((piece, index) => {
            const item = document.createElement('div');
            item.className = 'queue-item';
            if (index === 0) item.classList.add('active');
            const preview = document.createElement('canvas');
            preview.width = 72;
            preview.height = 72;
            const context = preview.getContext('2d');
            const tempTile = createTile(piece);
            drawTileInContext(context, tempTile, 6, 6, 60, now, { skipPulseFade: true });
            const meta = document.createElement('div');
            meta.className = 'meta';
            const title = document.createElement('span');
            title.className = 'title';
            title.textContent = piece.label;
            const hint = document.createElement('span');
            hint.className = 'hint';
            hint.textContent = index === 0 ? 'Deploy this next.' : 'On deck';
            meta.appendChild(title);
            meta.appendChild(hint);
            item.appendChild(preview);
            item.appendChild(meta);
            queueEl.appendChild(item);
          });
        }

        function refillQueue() {
          while (state.queue.length < QUEUE_SIZE) {
            const piece = PIECES[randomInt(PIECES.length)];
            state.queue.push({ ...piece, rotation: randomInt(4) });
          }
          drawQueue();
        }

        function resizeCanvas() {
          const rect = boardWrap.getBoundingClientRect();
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          drawBoard();
        }

        function traceChainForIntegrity() {
          if (!state.start) return { length: 0, complete: false };
          let current = { x: state.start.x, y: state.start.y };
          let incoming = 8;
          const visited = new Set();
          let length = 0;
          while (true) {
            const tile = state.board[current.y][current.x];
            if (!tile) break;
            const connectors = bitsFromMask(tileMask(tile));
            if (!connectors.includes(incoming)) break;
            length += 1;
            if (current.x === state.goal.x && current.y === state.goal.y) {
              return { length, complete: true };
            }
            const outgoing = connectors.filter((bit) => bit !== incoming);
            if (outgoing.length !== 1) break;
            const dir = DIRS.find((entry) => entry.bit === outgoing[0]);
            if (!dir) break;
            const nx = current.x + dir.dx;
            const ny = current.y + dir.dy;
            if (nx < 0 || nx >= state.gridSize || ny < 0 || ny >= state.gridSize) break;
            const key = `${nx},${ny},${dir.oppositeBit}`;
            if (visited.has(key)) break;
            const nextTile = state.board[ny][nx];
            if (!nextTile) {
              length += 0.25;
              break;
            }
            visited.add(key);
            current = { x: nx, y: ny };
            incoming = dir.oppositeBit;
          }
          return { length, complete: false };
        }

        function updateIntegrity() {
          const chain = traceChainForIntegrity();
          const ratio = state.targetPathLength ? Math.min(1, chain.length / state.targetPathLength) : 0;
          state.integrity = ratio;
          if (chain.complete && state.phase === 'build') {
            setMessage('Coolant route traced! Release when you are ready or squeeze in extra score.', 'success');
          }
          updateHud();
        }

        function rotateQueue(delta) {
          if (!state.queue.length) return;
          const piece = state.queue[0];
          piece.rotation = (piece.rotation + delta + 4) % 4;
          drawQueue();
        }

        function scrapQueuePiece() {
          if (!state.queue.length) return;
          state.queue.shift();
          adjustCountdown(-state.scrapPenalty);
          refillQueue();
          setMessage('Scrapped conduit. Surge accelerated.', 'danger');
        }

        function placeTile(x, y) {
          const tile = state.board[y][x];
          if (tile && tile.locked) {
            setMessage('Core fixtures are immutable. Route around them.');
            return;
          }
          if (!state.queue.length) {
            setMessage('Queue depleted. Hold on until new conduits arrive.');
            return;
          }
          if (!tile) {
            const piece = { ...state.queue.shift() };
            const placed = createTile(piece);
            placed.pulse = 1;
            state.board[y][x] = placed;
            refillQueue();
            updateIntegrity();
            drawBoard();
            setMessage('Conduit placed. Keep building towards the drain.');
          } else {
            tile.rotation = (tile.rotation + 1) % 4;
            tile.pulse = 1;
            updateIntegrity();
            drawBoard();
            setMessage('Orientation adjusted. Watch the flow vector.');
          }
        }

        function removeTile(x, y) {
          const tile = state.board[y][x];
          if (!tile || tile.locked) {
            setMessage('Cannot purge structural fixtures.');
            return;
          }
          state.board[y][x] = null;
          adjustCountdown(-3);
          setMessage('Conduit purged. Surge hastened by 3 seconds.', 'danger');
          updateIntegrity();
          drawBoard();
        }

        function handleBoardClick(event) {
          if (state.phase !== 'build') return;
          const rect = canvas.getBoundingClientRect();
          const tileSize = rect.width / state.gridSize;
          const x = Math.floor((event.clientX - rect.left) / tileSize);
          const y = Math.floor((event.clientY - rect.top) / tileSize);
          if (x < 0 || y < 0 || x >= state.gridSize || y >= state.gridSize) return;
          placeTile(x, y);
        }

        function handleContextMenu(event) {
          if (state.phase !== 'build') return;
          event.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const tileSize = rect.width / state.gridSize;
          const x = Math.floor((event.clientX - rect.left) / tileSize);
          const y = Math.floor((event.clientY - rect.top) / tileSize);
          if (x < 0 || y < 0 || x >= state.gridSize || y >= state.gridSize) return;
          if (event.shiftKey) {
            removeTile(x, y);
            return;
          }
          const tile = state.board[y][x];
          if (!tile || tile.locked) return;
          tile.rotation = (tile.rotation + 1) % 4;
          tile.pulse = 1;
          updateIntegrity();
          drawBoard();
        }

        function traceFlow() {
          if (!state.start || !state.goal) {
            return { success: false, sequence: [], failure: null, reason: 'Grid not initialized.' };
          }
          const sequence = [];
          const visited = new Set();
          let current = { x: state.start.x, y: state.start.y };
          let incoming = 8;
          while (true) {
            const key = `${current.x},${current.y}`;
            if (visited.has(key)) {
              return { success: false, sequence, failure: { x: current.x, y: current.y }, reason: 'Coolant loop detected. Too many junctions.' };
            }
            visited.add(key);
            const tile = state.board[current.y][current.x];
            if (!tile) {
              return { success: false, sequence, failure: { x: current.x, y: current.y }, reason: 'Gap in the conduit network.' };
            }
            const connectors = bitsFromMask(tileMask(tile));
            if (!connectors.includes(incoming)) {
              return { success: false, sequence, failure: { x: current.x, y: current.y }, reason: 'Orientation mismatch. Pressure leaking upstream.' };
            }
            sequence.push({ x: current.x, y: current.y });
            if (current.x === state.goal.x && current.y === state.goal.y) {
              if (connectors.includes(2)) {
                return { success: true, sequence, failure: null, reason: '' };
              }
              return { success: false, sequence, failure: { x: current.x, y: current.y }, reason: 'Drain not engaged.' };
            }
            const outgoing = connectors.filter((bit) => bit !== incoming);
            if (outgoing.length !== 1) {
              return { success: false, sequence, failure: { x: current.x, y: current.y }, reason: 'Flow split detected. Keep the conduit singular.' };
            }
            const dir = DIRS.find((entry) => entry.bit === outgoing[0]);
            if (!dir) {
              return { success: false, sequence, failure: { x: current.x, y: current.y }, reason: 'Routing failure.' };
            }
            const nx = current.x + dir.dx;
            const ny = current.y + dir.dy;
            if (nx < 0 || nx >= state.gridSize || ny < 0 || ny >= state.gridSize) {
              return { success: false, sequence, failure: { x: current.x, y: current.y }, reason: 'Coolant escaped the lattice bounds.' };
            }
            const nextTile = state.board[ny][nx];
            if (!nextTile) {
              return { success: false, sequence, failure: { x: nx, y: ny }, reason: 'Coolant hit an unbuilt segment.' };
            }
            incoming = dir.oppositeBit;
            current = { x: nx, y: ny };
          }
        }

        function animateFlow(sequence, success, reason, failureCell) {
          if (!sequence.length) {
            handleFailure(reason || 'Coolant failed to find a conduit.', failureCell || state.start);
            return;
          }
          state.flowActive = true;
          state.phase = 'flow';
          clearPendingTimeouts();
          resetWetness();
          updateHud();
          const total = sequence.length;
          sequence.forEach((cell, index) => {
            pushTimeout(() => {
              const tile = state.board[cell.y][cell.x];
              if (!tile) return;
              tile.wetProgress = 1;
              tile.pulse = 0.6;
              state.integrity = Math.min(1, (index + 1) / Math.max(1, state.targetPathLength));
              drawBoard();
              updateHud();
              if (index === total - 1) {
                pushTimeout(() => {
                  if (success) {
                    handleSuccess();
                  } else {
                    handleFailure(reason, failureCell || cell);
                  }
                }, 420);
              }
            }, index * 220);
          });
        }

        function handleSuccess() {
          state.phase = 'win';
          const reward = Math.round(180 + state.countdownRemaining * 8 + state.level * 12);
          state.score += reward;
          state.integrity = 1;
          updateHud();
          setMessage(`Coolant stabilized! +${reward} score. Reactor escalating.`, 'success');
          pushTimeout(() => {
            state.level += 1;
            initializeLevel();
          }, 1500);
        }

        function handleFailure(reason, cell) {
          state.phase = 'build';
          state.flowActive = false;
          state.failureCell = cell || null;
          state.lastFailureReason = reason || 'Coolant destabilized.';
          state.score = Math.max(0, state.score - 120);
          state.integrity = 0;
          state.countdownRemaining = Math.max(8, state.countdownRemaining - 2);
          state.initialCountdown = state.countdownRemaining;
          refillQueue();
          setMessage(`${state.lastFailureReason} Score penalty applied. Rebuild before the next surge.`, 'danger');
          updateHud();
          drawBoard();
          pushTimeout(() => {
            state.failureCell = null;
            drawBoard();
            startCountdown();
          }, 1600);
        }

        function runFlow() {
          if (state.flowActive) return;
          stopCountdown();
          const result = traceFlow();
          clearFlowState();
          animateFlow(result.sequence, result.success, result.reason, result.failure);
        }

        function startCountdown() {
          stopCountdown();
          state.phase = 'build';
          updateHud();
          setMessage('Rotate and deploy conduits. Surge will auto-trigger when the timer hits zero.');
          state.timerId = setInterval(() => {
            state.countdownRemaining -= 1;
            if (state.countdownRemaining <= 0) {
              stopCountdown();
              setMessage('Surge triggered! Hold on...', 'danger');
              runFlow();
            }
            updateHud();
          }, 1000);
        }

        function prepareBoard() {
          state.board = new Array(state.gridSize)
            .fill(null)
            .map(() => new Array(state.gridSize).fill(null));
          const startY = Math.floor(state.gridSize / 2);
          const goalY = Math.min(state.gridSize - 2, Math.max(1, startY + randomInt(5) - 2));
          state.start = { x: 0, y: startY };
          state.goal = { x: state.gridSize - 1, y: goalY };
          state.board[startY][0] = createTile({ type: 'source', baseMask: 2 | 8 }, { locked: true, special: 'start' });
          state.board[goalY][state.gridSize - 1] = createTile({ type: 'sink', baseMask: 2 | 8 }, { locked: true, special: 'goal' });
          const hazardCount = Math.min(4, Math.floor(state.level / 2));
          for (let i = 0; i < hazardCount; i += 1) {
            const hx = randomInt(state.gridSize - 2) + 1;
            const hy = randomInt(state.gridSize - 2) + 1;
            if ((hx === state.goal.x && hy === state.goal.y) || (hx === state.start.x && hy === state.start.y)) {
              continue;
            }
            if (state.board[hy][hx]) continue;
            const hazardPiece = PIECES[randomInt(4)];
            const blocker = createTile(hazardPiece, { locked: true, rotation: randomInt(4) });
            blocker.pulse = 0.2;
            state.board[hy][hx] = blocker;
          }
          state.targetPathLength = Math.abs(state.goal.x - state.start.x) + Math.abs(state.goal.y - state.start.y) + 3 + hazardCount;
        }

        function initializeLevel() {
          stopCountdown();
          clearPendingTimeouts();
          state.phase = 'build';
          state.flowActive = false;
          state.failureCell = null;
          state.queue = [];
          state.shimmerSeed = Math.random() * 360;
          state.initialCountdown = Math.max(14, 26 - state.level * 2);
          state.countdownRemaining = state.initialCountdown;
          prepareBoard();
          refillQueue();
          updateIntegrity();
          drawBoard();
          updateHud();
          setMessage('Fresh lattice online. Queue conduits and prep for the surge.');
          startCountdown();
        }

        function tick(timestamp) {
          drawBoard(timestamp);
          state.animationFrame = requestAnimationFrame(tick);
        }

        function init() {
          const resizeObserver = new ResizeObserver(resizeCanvas);
          resizeObserver.observe(boardWrap);
          registerCleanup(() => resizeObserver.disconnect());
          resizeCanvas();
          initializeLevel();
          state.animationFrame = requestAnimationFrame(tick);
          canvas.addEventListener('click', handleBoardClick);
          registerCleanup(() => canvas.removeEventListener('click', handleBoardClick));
          canvas.addEventListener('contextmenu', handleContextMenu);
          registerCleanup(() => canvas.removeEventListener('contextmenu', handleContextMenu));
          const rotateLeftHandler = () => rotateQueue(-1);
          const rotateRightHandler = () => rotateQueue(1);
          rotateLeftBtn.addEventListener('click', rotateLeftHandler);
          rotateRightBtn.addEventListener('click', rotateRightHandler);
          scrapBtn.addEventListener('click', scrapQueuePiece);
          registerCleanup(() => {
            rotateLeftBtn.removeEventListener('click', rotateLeftHandler);
            rotateRightBtn.removeEventListener('click', rotateRightHandler);
            scrapBtn.removeEventListener('click', scrapQueuePiece);
          });
          forceButton.addEventListener('click', runFlow);
          registerCleanup(() => forceButton.removeEventListener('click', runFlow));
          resetButton.addEventListener('click', initializeLevel);
          registerCleanup(() => resetButton.removeEventListener('click', initializeLevel));
          registerCleanup(() => {
            stopCountdown();
            clearPendingTimeouts();
            if (state.animationFrame) {
              cancelAnimationFrame(state.animationFrame);
            }
          });
        }

        init();
      })();
    </script>
  </body>
</html>
